const { createClient } = require('@supabase/supabase-js');
const fetch = require('node-fetch'); // For Discord webhook

exports.handler = async (event) => {
  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: JSON.stringify({ message: 'Method Not Allowed' }), headers: { 'Allow': 'POST' } };
  }

  const supabaseUrl = process.env.SUPABASE_URL;
  const supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY;
  const discordWebhookUrl = process.env.DISCORD_WEBHOOK_URL; // For notifications

  if (!supabaseUrl || !supabaseServiceKey) {
    console.error('Supabase URL or Service Key is missing for send-support-message.');
    return { statusCode: 500, body: JSON.stringify({ message: 'Server configuration error (Supabase).' }) };
  }
  const supabase = createClient(supabaseUrl, supabaseServiceKey);

  // Authenticate user (client sending the message)
  const authHeader = event.headers['authorization'];
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return { statusCode: 401, body: JSON.stringify({ message: 'Unauthorized: Missing or malformed token.' }) };
  }
  const token = authHeader.split(' ')[1];

  let clientUser;
  try {
    const { data: { user }, error: userError } = await supabase.auth.getUser(token);
    if (userError || !user) {
      console.error('Error fetching user from token for send-support-message:', userError?.message);
      return { statusCode: 401, body: JSON.stringify({ message: 'Unauthorized: Invalid client token.' }) };
    }
    clientUser = user;
  } catch (e) {
    console.error('Exception during client user authentication for send-support-message:', e);
    return { statusCode: 401, body: JSON.stringify({ message: 'Unauthorized: Client authentication error.' }) };
  }

  // Parse request body
  let body;
  try {
    body = JSON.parse(event.body);
  } catch (e) {
    return { statusCode: 400, body: JSON.stringify({ message: 'Bad Request: Invalid JSON.' }) };
  }

  const { category, message: message_content, conversationId: conversation_id } = body;
  // userId from JWT (clientUser.id) is the source of truth for who is sending.

  if (!clientUser.id || !category || !message_content || !conversation_id) {
    return { statusCode: 400, body: JSON.stringify({ message: 'Bad Request: Missing userId, category, message, or conversationId.' }) };
  }

  const messageData = {
    conversation_id: conversation_id,
    user_id: clientUser.id, // Authenticated user's ID
    sender_type: 'user',
    category: category,
    message: message_content,
    // created_at is auto-generated by Supabase
  };

  try {
    const { data: insertedMessages, error: insertError } = await supabase
      .from('support_messages')
      .insert([messageData])
      .select(); // Select to get the full row back, including created_at

    if (insertError) {
      console.error('Supabase insert error in send-support-message:', insertError);
      return { statusCode: 500, body: JSON.stringify({ message: 'Error saving message.' }) };
    }

    const insertedMessage = insertedMessages && insertedMessages[0];
    if (!insertedMessage) {
         console.error('Failed to retrieve inserted message from Supabase.');
         return { statusCode: 500, body: JSON.stringify({ message: 'Error confirming message save.' }) };
    }

    console.log('User support message saved:', insertedMessage);

    // Broadcast the new message via Supabase Realtime
    const rtChannelName = `conversation-${conversation_id}`;
    const broadcastPayload = {
      type: 'broadcast',
      event: 'new_support_message',
      payload: insertedMessage // Send the full message object as saved in DB
    };
    const { error: broadcastError } = await supabase.channel(rtChannelName).send(broadcastPayload);
    if (broadcastError) {
      console.error(`Error broadcasting user message to ${rtChannelName}:`, broadcastError);
    } else {
      console.log(`User message broadcasted to ${rtChannelName}`);
    }

    // Send Discord Notification
    if (discordWebhookUrl) {
      const userNameForDiscord = clientUser.user_metadata?.full_name || clientUser.user_metadata?.name || clientUser.email || clientUser.id;
      const discordMsg = `New Support Chat Message:
User: ${userNameForDiscord} (${clientUser.id})
Topic: ${category}
Conversation ID: ${conversation_id}
Message: ${message_content.substring(0, 200)}${message_content.length > 200 ? '...' : ''}`;

      fetch(discordWebhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: discordMsg }),
      }).catch(err => console.error('Error sending to Discord:', err)); // Log error, but don't fail request
    } else {
        console.warn('DISCORD_WEBHOOK_URL not set. Skipping Discord notification.');
    }

    return { statusCode: 201, body: JSON.stringify(insertedMessage) }; // Return the created message

  } catch (e) {
    console.error('Unexpected server error in send-support-message:', e);
    return { statusCode: 500, body: JSON.stringify({ message: 'Internal Server Error.' }) };
  }
};
